using Microsoft.CodeAnalysis;
using System.Text;

using static ECK1.CodeGen.Shared.Common.Common;
using static ECK1.CodeGen.Shared.Grpc.GrpcCommon;

namespace ECK1.GrpcService.Abstractions.CodeGen;

[Generator]
public class ServiceAbstractionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var symbolCollection  = GetTypesForCodeGenWithDepsByInterface(context, InterfaceName);

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(symbolCollection), (spc, data) =>
        {
            try
            {
                var (comp, symbols) = data;

                if (!symbols.Any())
                    return;

                var existing = comp.GetTypeByMetadataName($"{NsPrefix}.Generated.IEntityStoreGrpcService");

                if (existing != null)
                    return;

                GenerateIService(spc, symbols);

                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "GEN001",
                        title: "Generator Executed",
                        messageFormat: $"IService executed. Found {symbols.Count()} classes.",
                        category: "Generator",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    Location.None));

                spc.AddSource("CommonDto.g.cs", CommonDtoSource);
                spc.AddSource("BuildTimeInfo.IService.g.cs", $"// Generated at {DateTime.Now}");
            }
            catch (Exception e)
            {
                spc.AddSource("Exception.IService.g.cs", "// <auto-generated/>\n\n" + e);
            }
        });
    }

    private void GenerateIService(SourceProductionContext spc, IEnumerable<INamedTypeSymbol> symbols)
    {
        var sb = new StringBuilder();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.ServiceModel;");
        sb.AppendLine($"using {NsPrefix}.CommonDto.Generated;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NsPrefix}.Generated;");
        sb.AppendLine();
        sb.AppendLine("// Auto-generated");

        sb.AppendLine();
        sb.AppendLine("[ServiceContract]");
        sb.AppendLine("public partial interface IEntityStoreGrpcService");
        sb.AppendLine("{");

        foreach (var t in symbols)
        {
            try
            {
                sb.AppendLine(GenerateServiceActionForType(t));
            }
            catch (Exception ex)
            {
                spc.AddSource($"IService_ERR_{Guid.NewGuid():N}.g.cs",
                    $"// Service generator failed for {t?.ToDisplayString()}: {ex}");
            }
        }

        sb.AppendLine("}");

        spc.AddSource("EntityStoreGrpc.IService.g.cs", sb.ToString());
    }

    private string GenerateServiceActionForType(INamedTypeSymbol classSymbol)
    {
        var safeId = MakeSafeIdentifier(classSymbol);
        var typeText = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return $"    ValueTask<EntityResponse<{typeText}>> {BuildGrpcGetEntityMethodName(safeId)}(GetEntityRequest<{typeText}> request);";
    }

    private string CommonDtoSource => new StringBuilder().AppendLine("using ProtoBuf;")
        .AppendLine()
        .AppendLine($"namespace {NsPrefix}.CommonDto.Generated;")
        .AppendLine(@"
[ProtoContract]
public class FieldMask
{
    [ProtoMember(1)]
    public List<string> Paths { get; set; } = [];
}

[ProtoContract]
public class GetEntityRequest<T>")
    .AppendLine($"    where T : class, {InterfaceName}")
.AppendLine(@"{
    [ProtoMember(1)] public string Id { get; set; }
    [ProtoMember(2)] public int MinVersion { get; set; }
    [ProtoMember(3)] public FieldMask Mask { get; set; }
    [ProtoMember(4)] public int? FieldMaskHash { get; set; }
}

[ProtoContract]
public class EntityResponse<T>")
        .AppendLine($"    where T : class, {InterfaceName}")
        .AppendLine(@"{
    [ProtoMember(1)] public T Item { get; set; }
    [ProtoMember(2)] public int Version { get; set; }
    [ProtoMember(3)] public int? FieldMaskHash { get; set; }
}
").ToString();
}
