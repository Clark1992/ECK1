using Microsoft.CodeAnalysis;
using System.Text;

using static ECK1.CodeGen.Shared.Common.Common;

namespace ECK1.Integration.Plugin.Abstractions.CodeGen;

[Generator]
public sealed class ProjectionAccessorsGenerator : IIncrementalGenerator
{
    private const string ThinEventBaseMetadataName = "ECK1.IntegrationContracts.Kafka.IntegrationRecords.Generated.ThinEvent";
    private const string TargetNamespace = "ECK1.Integration.Plugin.Abstractions.ProjectionCompiler.Generated";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var recordTypes = GetTypesForCodeGenWithDepsByInterface(context, InterfaceName);
        var eventTypes = GetTypesForCodeGenWithDepsByBaseType(context, ThinEventBaseMetadataName);
        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(recordTypes).Combine(eventTypes),
            static (spc, data) =>
            {
                try
                {
                    var ((comp, records), events) = data;

                    EmitAll(spc, comp, [.. records], [.. events]);
                }
                catch (Exception ex)
                {
                    spc.AddSource("ProjectionAccessors.Exception.g.cs",
                        "// <auto-generated/>\n\n" + ex);
                }
            });
    }

    private static void EmitAll(
        SourceProductionContext spc,
        Compilation compilation,
        INamedTypeSymbol[] recordTypes,
        INamedTypeSymbol[] eventTypes)
    {
        recordTypes = [.. recordTypes
            .Where(t => t is { IsAbstract: false } && t.TypeKind == TypeKind.Class)
            .Distinct(SymbolEqualityComparer.Default)
            .Cast<INamedTypeSymbol>()];

        eventTypes = [.. eventTypes
            .Where(t => t is { IsAbstract: false } && t.TypeKind == TypeKind.Class)
            .Distinct(SymbolEqualityComparer.Default)
            .Cast<INamedTypeSymbol>()];

        var itemTypes = CollectItemTypes(recordTypes);

        var accessorTypes = recordTypes
            .Concat(eventTypes)
            .Distinct(SymbolEqualityComparer.Default)
            .Cast<INamedTypeSymbol>()
            .ToArray();

        static string AccessorMetadataName(INamedTypeSymbol t) =>
            $"{TargetNamespace}.{MakeSafeIdentifier(t)}_Accessors";

        bool HasType(string metadataName) => compilation.GetTypeByMetadataName(metadataName) is not null;
        bool HasAccessors(INamedTypeSymbol t) => HasType(AccessorMetadataName(t));

        var recordAccessorsToGenerate = recordTypes.Where(t => !HasAccessors(t)).ToArray();
        var eventAccessorsToGenerate = eventTypes.Where(t => !HasAccessors(t)).ToArray();
        var itemAccessorsToGenerate = itemTypes.Where(t => !HasAccessors(t)).ToArray();

        // Core glue must only be generated once (in the deepest dependency).
        var needsCore =
            !HasType($"{TargetNamespace}.ProjectionAccessorsRegistry") ||
            !HasType($"{TargetNamespace}.RecordAccessor`1") ||
            !HasType($"{TargetNamespace}.EventAccessor`1") ||
            !HasType($"{TargetNamespace}.ItemAccessor`1") ||
            !HasType($"{TargetNamespace}.ArrayTypesCompileInit");

        if (needsCore)
        {
            spc.AddSource("ProjectionAccessors.Registry.g.cs", GenerateRegistryCore());
            spc.AddSource("RecordAccessor.Core.g.cs", GenerateRecordAccessorCore());
            spc.AddSource("EventAccessor.Core.g.cs", GenerateEventAccessorCore());
            spc.AddSource("ItemAccessor.Core.g.cs", GenerateItemAccessorCore());
            spc.AddSource("ArrayTypesCompileInit.Core.g.cs", GenerateArrayTypesCompileInitCore());
        }

        // Per-type accessors (only if they are not already available from referenced projects)
        foreach (var t in recordAccessorsToGenerate.Concat(eventAccessorsToGenerate))
            spc.AddSource(MakeSafeFileName("Accessors", t), GenerateAccessorsForType(t));

        foreach (var item in itemAccessorsToGenerate)
            spc.AddSource(MakeSafeFileName("ItemAccessors", item), GenerateItemAccessorsForType(item));

        // Per-assembly registration (supports extending registries from test projects / plugins)
        // If core exists in referenced projects, we only emit registrations + the new type accessors.
        var registryWillBeAvailable = needsCore || HasType($"{TargetNamespace}.ProjectionAccessorsRegistry");
        if (registryWillBeAvailable)
        {
            var hasAnyNew = recordAccessorsToGenerate.Length != 0 || eventAccessorsToGenerate.Length != 0 || itemAccessorsToGenerate.Length != 0;
            if (hasAnyNew)
            {
                spc.AddSource(
                    "ProjectionAccessors.Registrations.g.cs",
                    GenerateRegistrations(recordAccessorsToGenerate, eventAccessorsToGenerate, itemAccessorsToGenerate));
            }
        }

        spc.AddSource("BuildTimeInfo.ProjectionAccessors.g.cs", $"// Generated at {DateTime.Now:O}");
    }

    private static INamedTypeSymbol[] CollectItemTypes(INamedTypeSymbol[] recordTypes)
    {
        var acc = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        void AddItemType(ITypeSymbol candidate)
        {
            if (candidate is null) return;
            if (candidate is IArrayTypeSymbol arr)
                candidate = arr.ElementType;

            if (candidate is not INamedTypeSymbol named) return;
            if (IsPrimitiveLike(named)) return;

            // Avoid System.* reference types
            var ns = named.ContainingNamespace?.ToDisplayString() ?? string.Empty;
            if (ns.StartsWith("System", StringComparison.Ordinal)) return;

            if (acc.Add(named))
            {
                // Recurse into its children arrays
                foreach (var prop in named.GetMembers().OfType<IPropertySymbol>())
                {
                    if (TryGetEnumerableElementType(prop.Type, out var elementType))
                        AddItemType(elementType);
                }
            }
        }

        foreach (var record in recordTypes)
        {
            foreach (var prop in GetAllInstanceProperties(record))
            {
                if (TryGetEnumerableElementType(prop.Type, out var elementType))
                    AddItemType(elementType);
            }
        }

        return [.. acc];
    }

    private static IEnumerable<IPropertySymbol> GetAllInstanceProperties(INamedTypeSymbol type)
    {
        for (INamedTypeSymbol t = type; t is not null; t = t.BaseType)
        {
            foreach (var p in t.GetMembers().OfType<IPropertySymbol>())
            {
                if (p.IsStatic) continue;
                yield return p;
            }
        }
    }

    private static string GenerateRegistryCore()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using ECK1.Integration.Plugin.Abstractions.ProjectionCompiler.PayloadCompiler.Json;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();

        sb.AppendLine("public interface IRecordArrayCompileHandler");
        sb.AppendLine("{");
        sb.AppendLine("    bool TryCompile<TEvent, TRecord>(JsonPlanCompiler<TEvent, TRecord> compiler, IConfigurationSection field, List<JsonOp<TEvent, TRecord>> ops, string path);");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("public interface IItemArrayCompileHandler");
        sb.AppendLine("{");
        sb.AppendLine("    bool TryCompile<TEvent, TRecord, TContainerItem>(JsonPlanCompiler<TEvent, TRecord> compiler, IConfigurationSection field, List<JsonOp<TEvent, TRecord>> ops, string path);");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("public static class ProjectionAccessorsRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly object _gate = new();");
        sb.AppendLine();

        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _recordInt = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _recordString = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _recordGuid = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _recordDateTime = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _recordDecimal = new();");
        sb.AppendLine("    private static readonly Dictionary<(Type container, Type item), Func<string, Delegate>> _recordEnumerable = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, IRecordArrayCompileHandler> _recordArrayHandlers = new();");
        sb.AppendLine();

        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _eventInt = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _eventString = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _eventGuid = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _eventDateTime = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _eventDecimal = new();");
        sb.AppendLine("    private static readonly Dictionary<(Type container, Type item), Func<string, Delegate>> _eventEnumerable = new();");
        sb.AppendLine();

        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _itemInt = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _itemString = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _itemGuid = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _itemDateTime = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, Func<string, Delegate>> _itemDecimal = new();");
        sb.AppendLine("    private static readonly Dictionary<(Type container, Type item), Func<string, Delegate>> _itemEnumerable = new();");
        sb.AppendLine("    private static readonly Dictionary<Type, IItemArrayCompileHandler> _itemArrayHandlers = new();");
        sb.AppendLine();

        sb.AppendLine("    public static void RegisterRecordInt(Type recordType, Func<string, Delegate> factory) { lock (_gate) _recordInt[recordType] = factory; }");
        sb.AppendLine("    public static void RegisterRecordString(Type recordType, Func<string, Delegate> factory) { lock (_gate) _recordString[recordType] = factory; }");
        sb.AppendLine("    public static void RegisterRecordGuid(Type recordType, Func<string, Delegate> factory) { lock (_gate) _recordGuid[recordType] = factory; }");
        sb.AppendLine("    public static void RegisterRecordDateTime(Type recordType, Func<string, Delegate> factory) { lock (_gate) _recordDateTime[recordType] = factory; }");
        sb.AppendLine("    public static void RegisterRecordDecimal(Type recordType, Func<string, Delegate> factory) { lock (_gate) _recordDecimal[recordType] = factory; }");
        sb.AppendLine("    public static void RegisterRecordEnumerable(Type recordType, Type itemType, Func<string, Delegate> factory) { lock (_gate) _recordEnumerable[(recordType, itemType)] = factory; }");
        sb.AppendLine("    public static void RegisterRecordArrayHandler(Type recordType, IRecordArrayCompileHandler handler) { lock (_gate) _recordArrayHandlers[recordType] = handler; }");
        sb.AppendLine();

        sb.AppendLine("    public static void RegisterEventInt(Type eventType, Func<string, Delegate> factory) { lock (_gate) _eventInt[eventType] = factory; }");
        sb.AppendLine("    public static void RegisterEventString(Type eventType, Func<string, Delegate> factory) { lock (_gate) _eventString[eventType] = factory; }");
        sb.AppendLine("    public static void RegisterEventGuid(Type eventType, Func<string, Delegate> factory) { lock (_gate) _eventGuid[eventType] = factory; }");
        sb.AppendLine("    public static void RegisterEventDateTime(Type eventType, Func<string, Delegate> factory) { lock (_gate) _eventDateTime[eventType] = factory; }");
        sb.AppendLine("    public static void RegisterEventDecimal(Type eventType, Func<string, Delegate> factory) { lock (_gate) _eventDecimal[eventType] = factory; }");
        sb.AppendLine("    public static void RegisterEventEnumerable(Type eventType, Type itemType, Func<string, Delegate> factory) { lock (_gate) _eventEnumerable[(eventType, itemType)] = factory; }");
        sb.AppendLine();

        sb.AppendLine("    public static void RegisterItemInt(Type itemType, Func<string, Delegate> factory) { lock (_gate) _itemInt[itemType] = factory; }");
        sb.AppendLine("    public static void RegisterItemString(Type itemType, Func<string, Delegate> factory) { lock (_gate) _itemString[itemType] = factory; }");
        sb.AppendLine("    public static void RegisterItemGuid(Type itemType, Func<string, Delegate> factory) { lock (_gate) _itemGuid[itemType] = factory; }");
        sb.AppendLine("    public static void RegisterItemDateTime(Type itemType, Func<string, Delegate> factory) { lock (_gate) _itemDateTime[itemType] = factory; }");
        sb.AppendLine("    public static void RegisterItemDecimal(Type itemType, Func<string, Delegate> factory) { lock (_gate) _itemDecimal[itemType] = factory; }");
        sb.AppendLine("    public static void RegisterItemEnumerable(Type itemType, Type childItemType, Func<string, Delegate> factory) { lock (_gate) _itemEnumerable[(itemType, childItemType)] = factory; }");
        sb.AppendLine("    public static void RegisterItemArrayHandler(Type itemType, IItemArrayCompileHandler handler) { lock (_gate) _itemArrayHandlers[itemType] = handler; }");
        sb.AppendLine();

        sb.AppendLine("    public static bool TryGetRecordInt(Type recordType, string name, out Delegate getter) => TryGet(_recordInt, recordType, name, out getter);");
        sb.AppendLine("    public static bool TryGetRecordString(Type recordType, string name, out Delegate getter) => TryGet(_recordString, recordType, name, out getter);");
        sb.AppendLine("    public static bool TryGetRecordGuid(Type recordType, string name, out Delegate getter) => TryGet(_recordGuid, recordType, name, out getter);");
        sb.AppendLine("    public static bool TryGetRecordDateTime(Type recordType, string name, out Delegate getter) => TryGet(_recordDateTime, recordType, name, out getter);");
        sb.AppendLine("    public static bool TryGetRecordDecimal(Type recordType, string name, out Delegate getter) => TryGet(_recordDecimal, recordType, name, out getter);");
        sb.AppendLine("    public static bool TryGetRecordEnumerable(Type recordType, Type itemType, string path, out Delegate getter) => TryGet(_recordEnumerable, (recordType, itemType), path, out getter);");
        sb.AppendLine("    public static bool TryGetRecordArrayHandler(Type recordType, out IRecordArrayCompileHandler handler)");
        sb.AppendLine("    {");
        sb.AppendLine("        return _recordArrayHandlers.TryGetValue(recordType, out handler);");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    public static bool TryGetEventInt(Type eventType, string name, out Delegate getter) => TryGet(_eventInt, eventType, name, out getter);");
        sb.AppendLine("    public static bool TryGetEventString(Type eventType, string name, out Delegate getter) => TryGet(_eventString, eventType, name, out getter);");
        sb.AppendLine("    public static bool TryGetEventGuid(Type eventType, string name, out Delegate getter) => TryGet(_eventGuid, eventType, name, out getter);");
        sb.AppendLine("    public static bool TryGetEventDateTime(Type eventType, string name, out Delegate getter) => TryGet(_eventDateTime, eventType, name, out getter);");
        sb.AppendLine("    public static bool TryGetEventDecimal(Type eventType, string name, out Delegate getter) => TryGet(_eventDecimal, eventType, name, out getter);");
        sb.AppendLine("    public static bool TryGetEventEnumerable(Type eventType, Type itemType, string path, out Delegate getter) => TryGet(_eventEnumerable, (eventType, itemType), path, out getter);");
        sb.AppendLine();

        sb.AppendLine("    public static bool TryGetItemInt(Type itemType, string path, out Delegate getter) => TryGet(_itemInt, itemType, path, out getter);");
        sb.AppendLine("    public static bool TryGetItemString(Type itemType, string path, out Delegate getter) => TryGet(_itemString, itemType, path, out getter);");
        sb.AppendLine("    public static bool TryGetItemGuid(Type itemType, string path, out Delegate getter) => TryGet(_itemGuid, itemType, path, out getter);");
        sb.AppendLine("    public static bool TryGetItemDateTime(Type itemType, string path, out Delegate getter) => TryGet(_itemDateTime, itemType, path, out getter);");
        sb.AppendLine("    public static bool TryGetItemDecimal(Type itemType, string path, out Delegate getter) => TryGet(_itemDecimal, itemType, path, out getter);");
        sb.AppendLine("    public static bool TryGetItemEnumerable(Type itemType, Type childItemType, string path, out Delegate getter) => TryGet(_itemEnumerable, (itemType, childItemType), path, out getter);");
        sb.AppendLine("    public static bool TryGetItemArrayHandler(Type itemType, out IItemArrayCompileHandler handler)");
        sb.AppendLine("    {");
        sb.AppendLine("        return _itemArrayHandlers.TryGetValue(itemType, out handler);");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static bool TryGet<TKey>(Dictionary<TKey, Func<string, Delegate>> map, TKey key, string path, out Delegate getter)");
        sb.AppendLine("        where TKey : notnull");
        sb.AppendLine("    {");
        sb.AppendLine("        if (map.TryGetValue(key, out var fn))");
        sb.AppendLine("        {");
        sb.AppendLine("            getter = fn(path);");
        sb.AppendLine("            return getter is not null;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        getter = null;");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateRecordAccessorCore()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine("internal static class RecordAccessor<TRecord>");
        sb.AppendLine("{");
        sb.AppendLine("    public static bool TryGetInt(string name, out Func<TRecord, int> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordInt(typeof(TRecord), name, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, int>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetString(string name, out Func<TRecord, string> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordString(typeof(TRecord), name, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, string>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetGuid(string name, out Func<TRecord, Guid> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordGuid(typeof(TRecord), name, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, Guid>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDateTime(string name, out Func<TRecord, DateTime> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordDateTime(typeof(TRecord), name, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, DateTime>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDecimal(string name, out Func<TRecord, decimal> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordDecimal(typeof(TRecord), name, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, decimal>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetEnumerable<TItem>(string path, out Func<TRecord, IEnumerable<TItem>> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordEnumerable(typeof(TRecord), typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TRecord, IEnumerable<TItem>>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateEventAccessorCore()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine("internal static class EventAccessor<TEvent>");
        sb.AppendLine("{");
        sb.AppendLine("    public static bool TryGetInt(string name, out Func<TEvent, int> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventInt(typeof(TEvent), name, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, int>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetString(string name, out Func<TEvent, string> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventString(typeof(TEvent), name, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, string>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetGuid(string name, out Func<TEvent, Guid> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventGuid(typeof(TEvent), name, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, Guid>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDateTime(string name, out Func<TEvent, DateTime> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventDateTime(typeof(TEvent), name, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, DateTime>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDecimal(string name, out Func<TEvent, decimal> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventDecimal(typeof(TEvent), name, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, decimal>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetEnumerable<TItem>(string path, out Func<TEvent, IEnumerable<TItem>> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetEventEnumerable(typeof(TEvent), typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TEvent, IEnumerable<TItem>>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateItemAccessorCore()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine("internal static class ItemAccessor<TItem>");
        sb.AppendLine("{");
        sb.AppendLine("    public static bool TryGetInt(string path, out Func<TItem, int> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemInt(typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, int>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetString(string path, out Func<TItem, string> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemString(typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, string>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetGuid(string path, out Func<TItem, Guid> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemGuid(typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, Guid>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDateTime(string path, out Func<TItem, DateTime> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemDateTime(typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, DateTime>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetDecimal(string path, out Func<TItem, decimal> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemDecimal(typeof(TItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, decimal>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetEnumerable<TChildItem>(string path, out Func<TItem, IEnumerable<TChildItem>> getter)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemEnumerable(typeof(TItem), typeof(TChildItem), path, out var d))");
        sb.AppendLine("        { getter = (Func<TItem, IEnumerable<TChildItem>>)(object)d!; return true; }");
        sb.AppendLine("        getter = null; return false;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateRegistrations(INamedTypeSymbol[] records, INamedTypeSymbol[] events, INamedTypeSymbol[] items)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using ECK1.Integration.Plugin.Abstractions.ProjectionCompiler.PayloadCompiler.Json;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();

        sb.AppendLine("internal static class ProjectionAccessorsModuleInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    internal static void Init()");
        sb.AppendLine("    {");

        void EmitScalarRegistrations(string kind, INamedTypeSymbol t)
        {
            var fq = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var accessor = $"{MakeSafeIdentifier(t)}_Accessors";

            sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}Int(typeof({fq}), static name => {accessor}.TryGetInt(name, out Func<{fq}, int> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}String(typeof({fq}), static name => {accessor}.TryGetString(name, out Func<{fq}, string> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}Guid(typeof({fq}), static name => {accessor}.TryGetGuid(name, out Func<{fq}, Guid> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}DateTime(typeof({fq}), static name => {accessor}.TryGetDateTime(name, out Func<{fq}, DateTime> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}Decimal(typeof({fq}), static name => {accessor}.TryGetDecimal(name, out Func<{fq}, decimal> g) ? g : null);");

            var elementTypes = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
            foreach (var p in GetAllInstanceProperties(t))
            {
                if (p.Parameters.Length != 0) continue;
                if (!TryGetEnumerableElementType(p.Type, out var el) || el is null) continue;
                elementTypes.Add(el);
            }

            foreach (var el in elementTypes.OrderBy(x => x.ToDisplayString(), System.StringComparer.Ordinal))
            {
                var fqEl = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($"        ProjectionAccessorsRegistry.Register{kind}Enumerable(typeof({fq}), typeof({fqEl}), static path => {accessor}.TryGetEnumerable<{fqEl}>(path, out Func<{fq}, IEnumerable<{fqEl}>> g) ? g : null);");
            }

            // Array compiler handler exists only for record.* and item.* contexts (records + items)
            if (kind == "Record")
            {
                var enumerableProps = GetAllInstanceProperties(t)
                    .Where(p => p.Parameters.Length == 0 && TryGetEnumerableElementType(p.Type, out _))
                    .Select(p => (PropName: p.Name, Element: GetEnumerableElementType(p.Type)))
                    .Where(x => x.Element is not null)
                    .Select(x => (x.PropName, ElementFq: x.Element!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                    .Distinct()
                    .OrderBy(x => x.PropName, StringComparer.Ordinal)
                    .ToArray();

                if (enumerableProps.Length != 0)
                {
                    var handlerName = $"RecordArrayHandler_{MakeSafeIdentifier(t)}";
                    sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterRecordArrayHandler(typeof({fq}), new {handlerName}());");
                }
            }

            sb.AppendLine();
        }

        foreach (var t in records.OrderBy(t => t.ToDisplayString(), StringComparer.Ordinal))
            EmitScalarRegistrations("Record", t);

        foreach (var t in events.OrderBy(t => t.ToDisplayString(), StringComparer.Ordinal))
            EmitScalarRegistrations("Event", t);

        foreach (var t in items.OrderBy(t => t.ToDisplayString(), StringComparer.Ordinal))
        {
            var fq = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var accessor = $"{MakeSafeIdentifier(t)}_Accessors";

            sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemInt(typeof({fq}), static path => {accessor}.TryGetInt(path, out Func<{fq}, int> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemString(typeof({fq}), static path => {accessor}.TryGetString(path, out Func<{fq}, string> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemGuid(typeof({fq}), static path => {accessor}.TryGetGuid(path, out Func<{fq}, Guid> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemDateTime(typeof({fq}), static path => {accessor}.TryGetDateTime(path, out Func<{fq}, DateTime> g) ? g : null);");
            sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemDecimal(typeof({fq}), static path => {accessor}.TryGetDecimal(path, out Func<{fq}, decimal> g) ? g : null);");

            var elementTypes = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
            foreach (var p in GetAllInstanceProperties(t))
            {
                if (p.Parameters.Length != 0) continue;
                if (!TryGetEnumerableElementType(p.Type, out var el) || el is null) continue;
                elementTypes.Add(el);
            }

            foreach (var el in elementTypes.OrderBy(x => x.ToDisplayString(), StringComparer.Ordinal))
            {
                var fqEl = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemEnumerable(typeof({fq}), typeof({fqEl}), static path => {accessor}.TryGetEnumerable<{fqEl}>(path, out Func<{fq}, IEnumerable<{fqEl}>> g) ? g : null);");
            }

            var enumerableProps = GetAllInstanceProperties(t)
                .Where(p => p.Parameters.Length == 0 && TryGetEnumerableElementType(p.Type, out _))
                .Select(p => (PropName: p.Name, Element: GetEnumerableElementType(p.Type)))
                .Where(x => x.Element is not null)
                .Select(x => (x.PropName, ElementFq: x.Element!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                .Distinct()
                .OrderBy(x => x.PropName, StringComparer.Ordinal)
                .ToArray();

            if (enumerableProps.Length != 0)
            {
                var handlerName = $"ItemArrayHandler_{MakeSafeIdentifier(t)}";
                sb.AppendLine($"        ProjectionAccessorsRegistry.RegisterItemArrayHandler(typeof({fq}), new {handlerName}());");
            }

            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        // Record array handlers
        foreach (var t in records.OrderBy(t => t.ToDisplayString(), StringComparer.Ordinal))
        {
            var enumerableProps = GetAllInstanceProperties(t)
                .Where(p => p.Parameters.Length == 0 && TryGetEnumerableElementType(p.Type, out _))
                .Select(p => (PropName: p.Name, Element: GetEnumerableElementType(p.Type)))
                .Where(x => x.Element is not null)
                .Select(x => (x.PropName, ElementFq: x.Element!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                .Distinct()
                .OrderBy(x => x.PropName, StringComparer.Ordinal)
                .ToArray();

            if (enumerableProps.Length == 0)
                continue;

            var handlerName = $"RecordArrayHandler_{MakeSafeIdentifier(t)}";
            sb.AppendLine($"internal sealed class {handlerName} : IRecordArrayCompileHandler");
            sb.AppendLine("{");
            sb.AppendLine("    public bool TryCompile<TEvent, TRecord>(JsonPlanCompiler<TEvent, TRecord> compiler, IConfigurationSection field, List<JsonOp<TEvent, TRecord>> ops, string path)");
            sb.AppendLine("    {");
            sb.AppendLine("        switch (path)");
            sb.AppendLine("        {");
            foreach (var p in enumerableProps)
            {
                sb.AppendLine($"            case \"{p.PropName}\":");
                sb.AppendLine($"                compiler.CompileArrayField<{p.ElementFq}>(field, ops);");
                sb.AppendLine("                return true;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Item array handlers
        foreach (var t in items.OrderBy(t => t.ToDisplayString(), StringComparer.Ordinal))
        {
            var enumerableProps = GetAllInstanceProperties(t)
                .Where(p => p.Parameters.Length == 0 && TryGetEnumerableElementType(p.Type, out _))
                .Select(p => (PropName: p.Name, Element: GetEnumerableElementType(p.Type)))
                .Where(x => x.Element is not null)
                .Select(x => (x.PropName, ElementFq: x.Element!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
                .Distinct()
                .OrderBy(x => x.PropName, StringComparer.Ordinal)
                .ToArray();

            if (enumerableProps.Length == 0)
                continue;

            var handlerName = $"ItemArrayHandler_{MakeSafeIdentifier(t)}";
            sb.AppendLine($"internal sealed class {handlerName} : IItemArrayCompileHandler");
            sb.AppendLine("{");
            sb.AppendLine("    public bool TryCompile<TEvent, TRecord, TContainerItem>(JsonPlanCompiler<TEvent, TRecord> compiler, IConfigurationSection field, List<JsonOp<TEvent, TRecord>> ops, string path)");
            sb.AppendLine("    {");
            sb.AppendLine("        switch (path)");
            sb.AppendLine("        {");
            foreach (var p in enumerableProps)
            {
                sb.AppendLine($"            case \"{p.PropName}\":");
                sb.AppendLine($"                compiler.CompileArrayFieldForItem<TContainerItem, {p.ElementFq}>(field, ops);");
                sb.AppendLine("                return true;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateAccessorsForType(INamedTypeSymbol type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine($"internal static class {MakeSafeIdentifier(type)}_Accessors");
        sb.AppendLine("{");

        var scalarAccessors = CollectScalarAccessors(type);

        EmitSwitchGetter(sb, type, "Int", "int", scalarAccessors.IntPaths);
        EmitSwitchGetter(sb, type, "String", "string", scalarAccessors.StringPaths);
        EmitSwitchGetter(sb, type, "Guid", "System.Guid", scalarAccessors.GuidPaths);
        EmitSwitchGetter(sb, type, "DateTime", "System.DateTime", scalarAccessors.DateTimePaths);
        EmitSwitchGetter(sb, type, "Decimal", "decimal", scalarAccessors.DecimalPaths);

        // Enumerable overloads (safe, type-checked). Even if no arrays exist, emit stubs.
        EmitEnumerableAccessors(sb, type);

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateItemAccessorsForType(INamedTypeSymbol type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine($"internal static class {MakeSafeIdentifier(type)}_Accessors");
        sb.AppendLine("{");

        var scalarAccessors = CollectScalarAccessors(type);
        EmitSwitchGetter(sb, type, "Int", "int", scalarAccessors.IntPaths);
        EmitSwitchGetter(sb, type, "String", "string", scalarAccessors.StringPaths);
        EmitSwitchGetter(sb, type, "Guid", "System.Guid", scalarAccessors.GuidPaths);
        EmitSwitchGetter(sb, type, "DateTime", "System.DateTime", scalarAccessors.DateTimePaths);
        EmitSwitchGetter(sb, type, "Decimal", "decimal", scalarAccessors.DecimalPaths);

        EmitEnumerableAccessors(sb, type);

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void EmitEnumerableAccessors(StringBuilder sb, INamedTypeSymbol type)
    {
        var fqType = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var enumerableProps = GetAllInstanceProperties(type)
            .Where(p => p.Parameters.Length == 0 && TryGetEnumerableElementType(p.Type, out _))
            .Select(p => (PropName: p.Name, Element: GetEnumerableElementType(p.Type)))
            .Where(x => x.Element is not null)
            .Select(x => (x.PropName, ElementFq: x.Element!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))
            .Distinct()
            .OrderBy(x => x.PropName, StringComparer.Ordinal)
            .ToArray();

        sb.AppendLine("    public static bool TryGetEnumerable<TItem>(string path, out Func<" + fqType + ", IEnumerable<TItem>> getter)");
        sb.AppendLine("    {");

        if (enumerableProps.Length == 0)
        {
            sb.AppendLine("        getter = null;");
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine();
            return;
        }

        sb.AppendLine("        switch (path)");
        sb.AppendLine("        {");

        foreach (var (propName, elementFq) in enumerableProps)
        {
            sb.AppendLine($"            case \"{propName}\":");
            sb.AppendLine($"                if (typeof(TItem) == typeof({elementFq}))");
            sb.AppendLine("                {");
            sb.AppendLine($"                    getter = (Func<{fqType}, IEnumerable<TItem>>)(object)(Func<{fqType}, IEnumerable<{elementFq}>>)(static x => x.{propName});");
            sb.AppendLine("                    return true;");
            sb.AppendLine("                }");
            sb.AppendLine("                break;");
            sb.AppendLine();
        }

        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        getter = null;");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static ITypeSymbol GetEnumerableElementType(ITypeSymbol type) => 
        TryGetEnumerableElementType(type, out var elementType) ? elementType : null;

    private static void EmitSwitchGetter(
        StringBuilder sb,
        INamedTypeSymbol type,
        string kindName,
        string returnType,
        IReadOnlyList<(string Path, string Expr)> cases)
    {
        var fqType = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        sb.AppendLine($"    public static bool TryGet{kindName}(");
        sb.AppendLine("        string name,");
        sb.AppendLine($"        out Func<{fqType}, {returnType}> getter)");
        sb.AppendLine("    {");

        if (cases.Count == 0)
        {
            sb.AppendLine("        getter = null;");
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine();
            return;
        }

        sb.AppendLine("        switch (name)");
        sb.AppendLine("        {");

        foreach (var c in cases.OrderBy(c => c.Path, StringComparer.Ordinal))
        {
            sb.AppendLine($"            case \"{c.Path}\":");
            sb.AppendLine($"                getter = {c.Expr};");
            sb.AppendLine("                return true;");
            sb.AppendLine();
        }

        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        getter = null;");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private sealed class ScalarAccessors(
        List<(string Path, string Expr)> IntPaths,
        List<(string Path, string Expr)> StringPaths,
        List<(string Path, string Expr)> GuidPaths,
        List<(string Path, string Expr)> DateTimePaths,
        List<(string Path, string Expr)> DecimalPaths)
    {
        public List<(string Path, string Expr)> IntPaths { get; } = IntPaths;
        public List<(string Path, string Expr)> StringPaths { get; } = StringPaths;
        public List<(string Path, string Expr)> GuidPaths { get; } = GuidPaths;
        public List<(string Path, string Expr)> DateTimePaths { get; } = DateTimePaths;
        public List<(string Path, string Expr)> DecimalPaths { get; } = DecimalPaths;
    }

    private static ScalarAccessors CollectScalarAccessors(INamedTypeSymbol root)
    {
        var ints = new List<(string, string)>();
        var strings = new List<(string, string)>();
        var guids = new List<(string, string)>();
        var dateTimes = new List<(string, string)>();
        var decimals = new List<(string, string)>();

        var recursionStack = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        void Walk(INamedTypeSymbol current, List<IPropertySymbol> chain)
        {
            // Prevent cycles, but do not globally block repeated types under different paths.
            if (!recursionStack.Add(current))
                return;

            foreach (var prop in GetAllInstanceProperties(current))
            {
                // Skip indexers
                if (prop.Parameters.Length != 0) continue;

                if (TryGetEnumerableElementType(prop.Type, out _))
                    continue;

                var t = UnwrapNullable(prop.Type);

                if (IsScalarSupported(t, out var scalarKind))
                {
                    var path = string.Join(".", chain.Select(p => p.Name).Concat([prop.Name]));
                    var expr = BuildGetterExpr(chain.Concat([prop]).ToArray(), scalarKind);

                    switch (scalarKind)
                    {
                        case ScalarKind.Int:
                            ints.Add((path, expr));
                            break;
                        case ScalarKind.String:
                            strings.Add((path, expr));
                            break;
                        case ScalarKind.Guid:
                            guids.Add((path, expr));
                            break;
                        case ScalarKind.DateTime:
                            dateTimes.Add((path, expr));
                            break;
                        case ScalarKind.Decimal:
                            decimals.Add((path, expr));
                            break;
                    }

                    continue;
                }

                if (t is INamedTypeSymbol named && !IsPrimitiveLike(named))
                {
                    // Avoid diving into System.* reference types
                    var ns = named.ContainingNamespace?.ToDisplayString() ?? string.Empty;
                    if (ns.StartsWith("System", StringComparison.Ordinal))
                        continue;

                    Walk(named, [.. chain, prop]);
                }
            }

            recursionStack.Remove(current);
        }

        Walk(root, []);

        return new ScalarAccessors(ints, strings, guids, dateTimes, decimals);
    }

    private enum ScalarKind
    {
        Int,
        String,
        Guid,
        DateTime,
        Decimal
    }

    private static bool IsScalarSupported(ITypeSymbol type, out ScalarKind kind)
    {
        kind = default;

        if (type.SpecialType == SpecialType.System_Int32)
        {
            kind = ScalarKind.Int;
            return true;
        }

        if (type.SpecialType == SpecialType.System_String)
        {
            kind = ScalarKind.String;
            return true;
        }

        if (type is INamedTypeSymbol named && named.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Guid")
        {
            kind = ScalarKind.Guid;
            return true;
        }

        if (type is INamedTypeSymbol namedDt && namedDt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.DateTime")
        {
            kind = ScalarKind.DateTime;
            return true;
        }

        if (type.SpecialType == SpecialType.System_Decimal)
        {
            kind = ScalarKind.Decimal;
            return true;
        }

        if (type.TypeKind == TypeKind.Enum)
        {
            // Surface enums as string via ToString()
            kind = ScalarKind.String;
            return true;
        }

        return false;
    }

    private static string BuildGetterExpr(IPropertySymbol[] chain, ScalarKind kind)
    {
        // chain is like: [Inner, InnerName]
        // We build: static r => r.Inner != null ? r.Inner.InnerName : null

        static string Access(string root, IEnumerable<IPropertySymbol> props)
            => root + "." + string.Join(".", props.Select(p => p.Name));

        var finalAccess = Access("r", chain);

        // If we have no reference segments, just direct access.
        var refSegments = chain
            .Take(chain.Length - 1)
            .Where(p => IsReferenceOrNullable(p.Type))
            .ToArray();

        string finalExpr;

        if (kind == ScalarKind.String && chain.Last().Type.TypeKind == TypeKind.Enum)
            finalExpr = finalAccess + ".ToString()";
        else if (kind == ScalarKind.Guid && IsNullableGuid(chain.Last().Type))
            finalExpr = finalAccess + ".Value";
        else if (kind == ScalarKind.Decimal && IsNullableDecimal(chain.Last().Type))
            finalExpr = finalAccess + ".Value";
        else
            finalExpr = finalAccess;

        if (refSegments.Length == 0)
            return $"static r => {finalExpr}";

        // null checks: r.A != null && r.A.B != null
        var checks = new List<string>();
        for (var i = 0; i < chain.Length - 1; i++)
        {
            var seg = chain[i];
            if (!IsReferenceOrNullable(seg.Type))
                continue;

            var segAccess = Access("r", chain.Take(i + 1));
            checks.Add($"{segAccess} != null");
        }

        var cond = string.Join(" && ", checks);

        string fallback;
        if (kind == ScalarKind.String) fallback = "null";
        else fallback = "default";

        return $"static r => {cond} ? {finalExpr} : {fallback}";
    }

    private static bool IsReferenceOrNullable(ITypeSymbol type)
    {
        if (type.IsReferenceType)
            return true;

        return type is INamedTypeSymbol named && named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;
    }

    private static bool IsNullableGuid(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol named) return false;
        if (named.OriginalDefinition.SpecialType != SpecialType.System_Nullable_T) return false;
        if (named.TypeArguments.Length != 1) return false;
        return named.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Guid";
    }

    private static bool IsNullableDecimal(ITypeSymbol type)
    {
        if (type is not INamedTypeSymbol named) return false;
        if (named.OriginalDefinition.SpecialType != SpecialType.System_Nullable_T) return false;
        if (named.TypeArguments.Length != 1) return false;
        return named.TypeArguments[0].SpecialType == SpecialType.System_Decimal;
    }

    private static ITypeSymbol UnwrapNullable(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol named &&
            named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
            named.TypeArguments.Length == 1)
        {
            return named.TypeArguments[0];
        }

        return type;
    }

    private static bool TryGetEnumerableElementType(ITypeSymbol type, out ITypeSymbol elementType)
    {
        elementType = null!;

        if (type is IArrayTypeSymbol arr)
        {
            elementType = arr.ElementType;
            return true;
        }

        if (type is INamedTypeSymbol named && named.IsGenericType && named.TypeArguments.Length == 1)
        {
            // List<T>, IReadOnlyList<T>, IEnumerable<T>, ICollection<T> ...
            var name = named.Name;
            if (name is "List" or "IEnumerable" or "IReadOnlyList" or "ICollection" or "IReadOnlyCollection")
            {
                elementType = named.TypeArguments[0];
                return true;
            }
        }

        return false;
    }

    private static string GenerateArrayTypesCompileInitCore()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using ECK1.Integration.Plugin.Abstractions.ProjectionCompiler.PayloadCompiler.Json;");
        sb.AppendLine("using Microsoft.Extensions.Configuration;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("namespace " + TargetNamespace + ";");
        sb.AppendLine();
        sb.AppendLine("public static class ArrayTypesCompileInit");
        sb.AppendLine("{");

        // Signature 1
        sb.AppendLine("    internal static void ArrayCompile<TEvent, TRecord>(");
        sb.AppendLine("        this JsonPlanCompiler<TEvent, TRecord> compiler,");
        sb.AppendLine("        IConfigurationSection field,");
        sb.AppendLine("        List<JsonOp<TEvent, TRecord>> ops)");
        sb.AppendLine("    {");
        sb.AppendLine("        var fullPath = field[\"context\"];" );
        sb.AppendLine("        if (fullPath.StartsWith(\"record.\"))");
        sb.AppendLine("        {");
        sb.AppendLine("            var path = fullPath.Substring(\"record.\".Length);");
        sb.AppendLine("            compiler.CompileArrayForRecord(field, ops, path);");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (fullPath.StartsWith(\"item.\"))");
        sb.AppendLine("        {");
        sb.AppendLine("            var path = fullPath.Substring(\"item.\".Length);");
        sb.AppendLine("            compiler.CompileArrayForItem<TEvent, TRecord, TRecord>(field, ops, path);");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Helper for record arrays
        sb.AppendLine("    private static void CompileArrayForRecord<TEvent, TRecord>(");
        sb.AppendLine("        this JsonPlanCompiler<TEvent, TRecord> compiler,");
        sb.AppendLine("        IConfigurationSection field,");
        sb.AppendLine("        List<JsonOp<TEvent, TRecord>> ops,");
        sb.AppendLine("        string path)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetRecordArrayHandler(typeof(TRecord), out var handler))");
        sb.AppendLine("            _ = handler.TryCompile(compiler, field, ops, path);");
        sb.AppendLine("        return;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Public helper for item arrays
        sb.AppendLine("    public static void CompileArrayForItem<TEvent, TRecord, TContainerItem>(");
        sb.AppendLine("        this JsonPlanCompiler<TEvent, TRecord> compiler,");
        sb.AppendLine("        IConfigurationSection field,");
        sb.AppendLine("        List<JsonOp<TEvent, TRecord>> ops,");
        sb.AppendLine("        string path)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ProjectionAccessorsRegistry.TryGetItemArrayHandler(typeof(TContainerItem), out var handler))");
        sb.AppendLine("            _ = handler.TryCompile<TEvent, TRecord, TContainerItem>(compiler, field, ops, path);");
        sb.AppendLine("        return;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Signature 2
        sb.AppendLine("    internal static void ArrayCompile<TEvent, TRecord, TItem>(");
        sb.AppendLine("        this JsonPlanCompiler<TEvent, TRecord> compiler,");
        sb.AppendLine("        IConfigurationSection field,");
        sb.AppendLine("        List<JsonOp<TEvent, TRecord>> ops)");
        sb.AppendLine("    {");
        sb.AppendLine("        var fullPath = field[\"context\"];" );
        sb.AppendLine("        if (fullPath.StartsWith(\"record.\"))");
        sb.AppendLine("        {");
        sb.AppendLine("            var path = fullPath.Substring(\"record.\".Length);");
        sb.AppendLine("            compiler.CompileArrayForRecord(field, ops, path);");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (fullPath.StartsWith(\"item.\"))");
        sb.AppendLine("        {");
        sb.AppendLine("            var path = fullPath.Substring(\"item.\".Length);");
        sb.AppendLine("            compiler.CompileArrayForItem<TEvent, TRecord, TItem>(field, ops, path);");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }
}
