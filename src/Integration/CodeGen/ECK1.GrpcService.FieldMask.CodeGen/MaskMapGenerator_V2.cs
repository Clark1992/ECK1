using Microsoft.CodeAnalysis;
using System.Text;

using static ECK1.GrpcService.CodeGen.Common.Common;

namespace ECK1.GrpcService.CodeGen
{
    [Generator]
    public class MaskMapGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var symbolCollection = GetTypesForCodeGenWithDepsByInterface(context, InterfaceName);

            var compilation = context.CompilationProvider;

            context.RegisterSourceOutput(compilation.Combine(symbolCollection), (spc, data) =>
            {
                try
                {
                    var (comp, symbols) = data;

                    var all = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                    foreach (var s in symbols)
                    {
                        string safeId = MakeSafeIdentifier(s);
                        var typeText = $"MaskMap_{safeId}";
                        var existing = comp.GetTypeByMetadataName(typeText);

                        if (existing != null)
                            continue;

                        CollectAllTypesRecursive(s, all);
                    }

                    foreach (var t in all)
                    {
                        try
                        {
                            string safeId = MakeSafeIdentifier(t);
                            var typeText = $"{NsPrefix}.FieldMask.Generated.MaskMap_{safeId}";
                            var existing = comp.GetTypeByMetadataName(typeText);

                            if (existing != null)
                                continue;

                            var src = GenerateMaskMapForType(t);
                            spc.AddSource(MakeSafeFileName("MaskMap", t), src);
                        }
                        catch (Exception ex)
                        {
                            spc.AddSource($"MaskMap_ERR_{Guid.NewGuid():N}.g.cs",
                                $"// MaskMap generator failed for {t?.ToDisplayString()}: {ex}");
                        }
                    }

                    foreach (var t in symbols)
                    {
                        try
                        {
                            string safeId = MakeSafeIdentifier(t);
                            var typeText = $"{NsPrefix}.FieldMask.Helpers.Generated.MaskMap_{safeId}_Cache";
                            var existing = comp.GetTypeByMetadataName(typeText);

                            if (existing != null)
                                continue;

                            var src = GenerateMaskHelperForRootType(t);
                            spc.AddSource(MakeSafeFileName("MaskMapCache", t), src);
                        }
                        catch (Exception ex)
                        {
                            spc.AddSource($"MaskMapCache_ERR_{Guid.NewGuid():N}.g.cs",
                                $"// MaskMap: Helper generator failed for {t?.ToDisplayString()}: {ex}");
                        }
                    }

                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "GEN002",
                            title: "Generator Executed",
                            messageFormat: $"MaskMapGenerator executed. Found {all.Count} classes: {string.Join(", ", all.Select(s => s.Name))}",
                            category: "Generator",
                            DiagnosticSeverity.Warning,
                            isEnabledByDefault: true),
                        Location.None));

                    if (symbols.Any())
                    {
                        var existing = comp.GetTypeByMetadataName($"{NsPrefix}.FieldMask.Helpers.Generated.CacheNotFoundException");

                        if (existing is null)
                            spc.AddSource("Exceptions.g.cs", ExceptionsSource);
                        spc.AddSource("BuildTimeInfo.g.cs", $"// Generated at {DateTime.Now}");
                    }
                }
                catch (Exception e)
                {
                    spc.AddSource("Exception.g.cs", "// <auto-generated/>\n\n" + e);
                }
            });
        }

        private string GenerateMaskMapForType(INamedTypeSymbol classSymbol)
        {
            var sb = new StringBuilder();

            string safeId = MakeSafeIdentifier(classSymbol);
            string typeFQN = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            sb.AppendLine($"namespace {NsPrefix}.FieldMask.Generated;");
            sb.AppendLine();
            sb.AppendLine($"public class MaskMap_{safeId}");
            sb.AppendLine("{");
            sb.AppendLine($"    private readonly bool isEmptyMask;");
            sb.AppendLine($"    private int hash;");
            sb.AppendLine($"    private MaskMap_{safeId}(bool isEmptyMask)");
            sb.AppendLine("    {");
            sb.AppendLine("        this.isEmptyMask = isEmptyMask;");
            sb.AppendLine("    }");

            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>().Where(p => p.SetMethod is not null);

            foreach (var property in properties)
            {
                string propName = property.Name;
                var type = property.Type;

                if (IsPrimitiveLike(type))
                {
                    sb.AppendLine($"    private bool copy{propName};");
                }
                else
                {
                    type = IsListType(type, out var elementType) ? elementType : type;

                    sb.AppendLine($"    private bool copy{propName}Ref;");
                    sb.AppendLine($"    private bool copy{propName};");
                    sb.AppendLine($"    private MaskMap_{MakeSafeIdentifier(type)} copy{propName}MaskMap;");
                }
            }

            sb.AppendLine();
            sb.AppendLine("    public int Hash => hash;");
            sb.AppendLine();
            sb.AppendLine($"    public static MaskMap_{safeId} Create(IReadOnlyList<string> mask = null)");
            sb.AppendLine("    {");
            sb.AppendLine($"        MaskMap_{safeId} result;");
            sb.AppendLine("        if (mask is null or [])");
            sb.AppendLine($"            result = new MaskMap_{safeId}(true);");
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            sb.AppendLine($"            result = new MaskMap_{safeId}(false);");
            sb.AppendLine("            var masksByProp = mask.Select(m => m.Split('.', 2)).GroupBy(parts => parts[0]);");
            sb.AppendLine("            foreach (var group in masksByProp)");
            sb.AppendLine("            {");
            sb.AppendLine("                switch (group.Key.ToUpperInvariant())");
            sb.AppendLine("                {");

            foreach (var property in properties)
            {
                var (propName, type, isPrimitive, _) = GetPropertyData(property);

                sb.AppendLine($"                    case \"{propName.ToUpperInvariant()}\":");
                sb.AppendLine("                    {");

                if (isPrimitive)
                {
                    sb.AppendLine($"                        result.copy{propName} = true;");
                }
                else
                {
                    sb.AppendLine("                        if (group.Any(m => m.Length == 1))");
                    sb.AppendLine($"                            result.copy{propName}Ref = true;");
                    sb.AppendLine("                        else");
                    sb.AppendLine("                        {");
                    sb.AppendLine("                            var subMasks = group.Where(m => m.Length > 1).Select(m => m[1]).ToArray();");
                    sb.AppendLine("                            if (subMasks.Length > 0)");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                result.copy{propName} = true;");
                    sb.AppendLine($"                                result.copy{propName}MaskMap = MaskMap_{MakeSafeIdentifier(type)}.Create(subMasks);");
                    sb.AppendLine("                            }");
                    sb.AppendLine("                        }");
                }

                sb.AppendLine("                        break;");
                sb.AppendLine("                    }");
            }

            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        result.hash = result.ComputeHash();");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");

            sb.AppendLine();
            sb.AppendLine($"    internal {typeFQN} ApplyMask({typeFQN} src)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (isEmptyMask)");
            sb.AppendLine("            return src;");
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            sb.AppendLine($"            var dst = new {typeFQN}();");

            foreach (var property in properties)
            {
                var (propName, type, isPrimitive, isList) = GetPropertyData(property);

                if (isPrimitive)
                    sb.AppendLine($"            if(copy{propName}) dst.{propName} = src.{propName};");
                else if (isList)
                {
                    sb.AppendLine($"            if(copy{propName}Ref) dst.{propName} = src.{propName};");
                    sb.AppendLine($"            else if (copy{propName} && src.{propName} is not null)");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                var dstTmp = new {type}[src.{propName}.Count];");
                    sb.AppendLine();
                    sb.AppendLine($"                if (src.{propName}.Count <= 100)");
                    sb.AppendLine("                {");
                    sb.AppendLine($"                    for (int i = 0; i < src.{propName}.Count; i++)");
                    sb.AppendLine("                    {");
                    sb.AppendLine($"                         dstTmp[i] = copy{propName}MaskMap.ApplyMask(src.{propName}[i]);");
                    sb.AppendLine("                    }");
                    sb.AppendLine("                }");
                    sb.AppendLine("                else");
                    sb.AppendLine("                {");
                    sb.AppendLine($"                     Parallel.For(0, src.{propName}.Count, i =>");
                    sb.AppendLine("                     {");
                    sb.AppendLine($"                         dstTmp[i] = copy{propName}MaskMap.ApplyMask(src.{propName}[i]);");
                    sb.AppendLine("                     });");
                    sb.AppendLine("                }");
                    sb.AppendLine();
                    sb.AppendLine($"                 dst.{propName} = new List<{type}>(dstTmp);");
                    sb.AppendLine("            }");
                }
                else
                {
                    sb.AppendLine($"            if(copy{propName}Ref) dst.{propName} = src.{propName};");
                    sb.AppendLine($"            else if (copy{propName} && src.{propName} is not null) dst.{propName} = copy{propName}MaskMap.ApplyMask(src.{propName});");
                }
            }

            sb.AppendLine("            return dst;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    internal int ComputeHash()");
            sb.AppendLine("    {");
            sb.AppendLine("        var hash = new HashCode();");

            sb.AppendLine("        hash.Add(isEmptyMask);");

            foreach (var property in properties)
            {
                var (propName, _, isPrimitive, _) = GetPropertyData(property);
                if (isPrimitive)
                    sb.AppendLine($"        hash.Add(copy{propName});");
                else
                {
                    sb.AppendLine($"        hash.Add(copy{propName}Ref);");
                    sb.AppendLine($"        hash.Add(copy{propName});");
                    sb.AppendLine($"        if(copy{propName}MaskMap is not null)");
                    sb.AppendLine($"            hash.Add(copy{propName}MaskMap.Hash);");
                }
            }
            sb.AppendLine("        return hash.ToHashCode();");
            sb.AppendLine("    }");

            sb.AppendLine("}"); // end class
            sb.AppendLine();

            return sb.ToString();
        }

        private string GenerateMaskHelperForRootType(INamedTypeSymbol classSymbol)
        {
            var sb = new StringBuilder();

            string safeId = MakeSafeIdentifier(classSymbol);
            string maskMapType = $"MaskMap_{safeId}";

            sb.AppendLine($"using System;");
            sb.AppendLine($"using System.Collections.Concurrent;");
            sb.AppendLine($"using System.Collections.Generic;");
            sb.AppendLine($"using {NsPrefix}.FieldMask.Generated;");
            sb.AppendLine();
            sb.AppendLine($"namespace {NsPrefix}.FieldMask.Helpers.Generated;");
            sb.AppendLine($"public class MaskMap_{safeId}_Cache");
            sb.AppendLine("{");
            sb.AppendLine($"    private static readonly ConcurrentDictionary<int, {maskMapType}> _cache = new();");
            sb.AppendLine();
            sb.AppendLine($"    public static {maskMapType} GetMaskMap(IReadOnlyList<string> mask)");
            sb.AppendLine("    {");
            sb.AppendLine($"        var map = {maskMapType}.Create(mask);");
            sb.AppendLine("        _cache.AddOrUpdate(map.Hash, _ => map, (_, _) => map);");
            sb.AppendLine();
            sb.AppendLine("        return map;");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine($"    public static {maskMapType} GetMaskMap(int maskHash) => _cache.TryGetValue(maskHash, out var maskMap) ? maskMap : null;");
            sb.AppendLine();

            sb.AppendLine("}"); // end class
            sb.AppendLine();

            return sb.ToString();
        }

        private string ExceptionsSource => new StringBuilder()
            .AppendLine(@$"
using System;

namespace {NsPrefix}.FieldMask.Helpers.Generated;")
            .AppendLine(@"

internal class CacheNotFoundException(string Message) : Exception($""{nameof(CacheNotFoundException)}: {Message}"")
{
}

internal class MissingChildPropMask(string Message) : Exception($""{nameof(MissingChildPropMask)}: {Message}"")
{
}
").ToString();
    }
}
