using Microsoft.CodeAnalysis;
using System.Text;

using static ECK1.CodeGen.Shared.Common.Common;
using static ECK1.CodeGen.Shared.Grpc.GrpcCommon;

namespace ECK1.GrpcService.FieldMask.CodeGen;

[Generator]
public class FieldMaskGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var symbolCollection  = GetTypesForCodeGenWithDepsByInterface(context, InterfaceName);

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(symbolCollection), (spc, data) =>
        {
            try
            {
                var (comp, symbols) = data;

                foreach (var t in symbols)
                {
                    try
                    {
                        string safeId = MakeSafeIdentifier(t);
                        var typeText = $"FieldMaskApplier_{safeId}";
                        var existing = comp.GetTypeByMetadataName(typeText);

                        if (existing != null)
                            continue;

                        var src = GenerateApplierForType(t);
                        spc.AddSource(MakeSafeFileName("FieldMask", t), src);
                    }
                    catch (Exception ex)
                    {
                        spc.AddSource($"FieldMask_ERR_{Guid.NewGuid():N}.g.cs",
                            $"// FieldMask generator failed for {t?.ToDisplayString()}: {ex}");
                    }
                }

                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "GEN001",
                        title: "Generator Executed",
                        messageFormat: $"FieldMaskGenerator executed. Found {symbols.Count()} classes: {string.Join(",", symbols.Select(s => s.Name))}",
                        category: "Generator",
                        DiagnosticSeverity.Warning,
                        isEnabledByDefault: true),
                    Location.None));

                if (symbols.Any())
                {
                    spc.AddSource("BuildTimeInfo.g.cs", $"// Generated at {DateTime.Now}");
                }
            }
            catch (Exception e)
            {
                spc.AddSource("Exception.g.cs", "// <auto-generated/>\n\n" + e);
            }
        });
    }

    private string GenerateApplierForType(INamedTypeSymbol classSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine($"using {NsPrefix}.FieldMask.Helpers.Generated;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NsPrefix}.FieldMask.Generated;");

        var safeId = MakeSafeIdentifier(classSymbol);
        var typeText = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        sb.AppendLine($"// Auto-generated FieldMask applier for {classSymbol.ToDisplayString()}");
        sb.AppendLine($"public static class FieldMaskApplier_{safeId}");
        sb.AppendLine("{");
        sb.AppendLine();
        sb.AppendLine($"    public static ({typeText} Item, int? MaskMapCachedHash) ApplyRoot({typeText} src, IReadOnlyList<string> mask = null, int? maskHash = null)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Hot path");
        sb.AppendLine("        if (maskHash.HasValue)");
        sb.AppendLine("        {");
        sb.AppendLine($"            MaskMap_{safeId} map = MaskMap_{safeId}_Cache.GetMaskMap(maskHash.Value);");
        sb.AppendLine("            if (map is not null)");
        sb.AppendLine("            {");
        sb.AppendLine("                return (map.ApplyMask(src), map.Hash);");
        sb.AppendLine("            }");
        sb.AppendLine("            else if (mask is null)");
        sb.AppendLine("                throw new CacheNotFoundException(\"Hash not found / Mask not specified\");");
        sb.AppendLine("        }");

        sb.AppendLine("        if (src == null) return (null, null);");
        sb.AppendLine();
        sb.AppendLine("        // Hash/Mask are not set means just return source with no masking");
        sb.AppendLine("        if (!maskHash.HasValue && mask is null or []) return (src, null);");
        sb.AppendLine("        else");
        sb.AppendLine("        {");
        sb.AppendLine($"            MaskMap_{safeId} map = MaskMap_{safeId}_Cache.GetMaskMap(mask);");
        sb.AppendLine("            return (map.ApplyMask(src), map.Hash);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("}");
        sb.AppendLine();

        return sb.ToString();
    }
}
